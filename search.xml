<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode_problem_4_Median_of_Two_Sorted_Arrays]]></title>
    <url>%2F%E9%A2%98%E8%A7%A3%2FLeetCode%2FLeetCode-problem-4-Median-of-Two-Sorted-Arrays%2F</url>
    <content type="text"><![CDATA[问题描述There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). 找中间数字。 例子Example 1:nums1 = [1, 3]nums2 = [2]The median is 2.0 Example 2:nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 思路 合并两个数组，然后找到中间值。这是最笨的方法。 题目没有要求输出合并后的数组，所以没必要全部比较，可以记录比较的长度，只要达到中间长度就停止。 进一步优化，不用辅助数组，试探性查找。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243 /** * 将两者不完全合并，即只要合并到len长度即可。* 用了一个辅助vector。 68ms*/ double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int len1 = nums1.size(), len2=nums2.size(); int len = (len1+len2)/2, f = (len1+len2)%2; vector&lt;int&gt; tem; double ans = 0; int i = 0, j= 0; while(i&lt;len1&amp;&amp;j&lt;len2&amp;&amp;i+j&lt;len+1)&#123; if(nums1[i]&gt;nums2[j])&#123; tem.push_back(nums2[j]); j++; &#125;else&#123; tem.push_back(nums1[i]); i++; &#125; cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;endl; &#125; while(i+j&lt;len+1)&#123; if(i&lt;len1)&#123; tem.push_back(nums1[i]); i++; &#125; if(j&lt;len2)&#123; tem.push_back(nums2[j]); j++; &#125; cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;endl; &#125; cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;" "&lt;&lt;len&lt;&lt;endl; if(f&gt;0)&#123; ans = tem[len]; &#125;else&#123; ans = double(tem[len-1]+tem[len])/2; &#125; return ans; &#125; 不用vector12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 /*** 不用vector 思路一样 但用了更长的时间 90ms*/double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int len1 = nums1.size(), len2=nums2.size(); int len = (len1+len2)/2, f = (len1+len2)%2; double ans = 0, tem = 0; int i = 0, j= 0; while(i&lt;len1&amp;&amp;j&lt;len2&amp;&amp;i+j&lt;len+1)&#123; if(nums1[i]&gt;nums2[j])&#123; if(i+j==len-1)&#123; tem = nums2[j]; &#125; if(i+j==len)&#123; ans = nums2[j]; &#125; j++; &#125;else&#123; if(i+j==len-1)&#123; tem = nums1[i]; &#125; if(i+j==len)&#123; ans = nums1[i]; &#125; i++; &#125; cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;endl; &#125; while(i+j&lt;len+1)&#123; if(i&lt;len1)&#123; if(i+j==len-1)&#123; tem = nums1[i]; &#125; if(i+j==len)&#123; ans = nums1[i]; &#125; i++; &#125; if(j&lt;len2)&#123; if(i+j==len-1)&#123; tem = nums2[j]; &#125; if(i+j==len)&#123; ans = nums2[j]; &#125; j++; &#125; cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;endl; &#125; cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;" "&lt;&lt;len&lt;&lt;endl; if(f&gt;0)&#123; return ans; &#125;else&#123; return (ans+tem)/2; &#125; &#125; 进一步优化123456789101112131415161718192021222324252627282930313233343536 /*** 例程，55ms**/ double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int len1 = nums1.size(), len2=nums2.size(); if(len1&gt;len2)&#123; vector&lt;int&gt; tem = nums1; nums1 = nums2; nums2=tem; int t = len1; len1 = len2; len2 = t; &#125; int iMin = 0, iMax = len1, half = (len1+len2+1)/2; while(iMin &lt;= iMax)&#123; int i = (iMin + iMax)/2; int j = half - i; if (i &lt; iMax &amp;&amp; nums2[j-1] &gt; nums1[i])&#123; iMin = iMin + 1; // i is too small &#125; else if (i &gt; iMin &amp;&amp; nums1[i-1] &gt; nums2[j]) &#123; iMax = iMax - 1; // i is too big &#125; else &#123; // i is perfect int maxLeft = 0; if (i == 0) &#123; maxLeft =nums2[j-1]; &#125; else if (j == 0) &#123; maxLeft = nums1[i-1]; &#125; else &#123; maxLeft = max(nums1[i-1], nums2[j-1]); &#125; if ( (len1 + len2) % 2 == 1 ) &#123; return maxLeft; &#125; int minRight = 0; if (i == len1) &#123; minRight = nums2[j]; &#125; else if (j == len2) &#123; minRight = nums1[i]; &#125; else &#123; minRight = min(nums2[j], nums1[i]); &#125; return (maxLeft + minRight) / 2.0; &#125; &#125; return 0.0; &#125;]]></content>
      <categories>
        <category>题解</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
        <tag>中间数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_problem_3_Longest_Substring_Without_Repeating_Characters]]></title>
    <url>%2F%E9%A2%98%E8%A7%A3%2FLeetCode%2FLeetCode-problem-3-Longest-Substring-Without-Repeating-Characters%2F</url>
    <content type="text"><![CDATA[问题描述 Given a string, find the length of the longest substring without repeating characters. （找出最长的没有重复字母出现的子串。输出其最长长度。） 例子 Given “abcabcbb”, the answer is “abc”, which the length is 3. Given “bbbbb”, the answer is “b”, with the length of 1. Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring. 思路 有一个结论只要重复出现，index之前的东西就失去了作用，只用记录index之后的字符。 如果不是重复字符， index==-1 ,那么就让max++; 如果不是重复字符，index!=-1，就比较记录max。不能直接max++，也不能直接max=i-index; 例如：abcaad 如果出现重复，并且是在index之后出现，给记录，再比较max 如果出现重复，在index之前出现，比较记录max 测试用例&quot;abcabcss&quot; 4 &quot;aaaaa&quot; 1 &quot;qwwwejw&quot; 3 &quot;abcade&quot; 5 &quot;abba&quot; 2 index之前的就不算了 &quot;ohomm&quot; 3 &quot;tmmzuxt&quot; 5 因为t出现过，所以return的判断还是有必要的 &quot;alouzxilkaxkufsu&quot; 8 代码12345678910111213141516171819202122232425262728293031class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int index = -1; //每遇到重复值，就记录下其第一次出现的下标 int max = 0, len = s.size(); //max记录当前最长 int mapping[200] = &#123;0&#125;; int val; // 记录字符 for(int i = 0; i &lt; len; i ++)&#123; val = s[i]; //如果出现过，并且是在index之后出现，给记录 if(mapping[val]&gt;0)&#123; if(index &lt;= mapping[val]-1)&#123; index = mapping[val]-1; &#125; max = max&gt;=i-index?max:i-index; &#125; //if(index==-1) max++; // if(mapping[val]&lt;=0) &#123; if(index==-1) max++; else&#123; max = max&gt;=i-index?max:i-index; &#125; &#125; cout&lt;&lt;index&lt;&lt;" "&lt;&lt;max&lt;&lt;" "&lt;&lt;val&lt;&lt;endl; mapping[val] = i+1; &#125; if(index == -1) return max; else return max&gt;=len-index-1?max:len-index-1; &#125;&#125;; 改进版1234567891011121314 int lengthOfLongestSubstring(string s) &#123; int index = 0; //每遇到重复值，就记录下其第一次出现的下标 int max = 0, len = s.size(); //max记录当前最长 int mapping[200] = &#123;0&#125;; int val; // 记录字符 for(int i = 0; i &lt; len; i ++)&#123; val = s[i]; index = mapping[val]&gt;index?mapping[val]:index; max = max&gt;i-index+1?max:i-index+1; mapping[val] = i+1; &#125; return max; &#125; 补充ASCII码 &apos;a&apos; 97 &apos;A&apos; 65 &apos;0&apos; 48 &apos;z&apos; 122 &apos;Z&apos; 90 &apos;9&apos; 57]]></content>
      <categories>
        <category>题解</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
        <tag>最长子串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_problem_2_Add_Two_Numbers]]></title>
    <url>%2F%E9%A2%98%E8%A7%A3%2FLeetCode%2FLeetCode-problem-2-Add-Two-Numbers%2F</url>
    <content type="text"><![CDATA[问题描述You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. 假定两个数都不是0开头，除了数本身就是0。 例子Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 思路题目没什么难点，就是链表的顺序遍历问题。注意进位就行了，可能最后有一个进位要再创建一个节点，不要漏掉。 代码1234567891011121314151617181920212223242526272829303132333435363738/** * C++ 代码 * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode head(-1); int f = 0; //标识进位 ListNode* pre = &amp;head; ListNode* pa = l1, *pb = l2; int val = 0, a, b; while(pa!=nullptr||pb!=nullptr)&#123; a = pa == nullptr?0:pa-&gt;val; b = pb == nullptr?0:pb-&gt;val; val = a + b + f; f = val / 10; val = val % 10; pre-&gt;next = new ListNode(val); pa=pa==nullptr?nullptr:pa-&gt;next; pb=pb==nullptr?nullptr:pb-&gt;next; pre = pre-&gt;next; &#125; //最后判断是否有进位 if(f&gt;0)&#123; pre-&gt;next = new ListNode(f); &#125; return head.next; &#125;&#125;;]]></content>
      <categories>
        <category>题解</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_problem_1_two_sum]]></title>
    <url>%2F%E9%A2%98%E8%A7%A3%2FLeetCode%2FLeetCode-problem-1-two-sum%2F</url>
    <content type="text"><![CDATA[Description Given an array of integers, return indices of the two numbers suchthat they add up to a specific target. You may assume that each input would have exactly one solution, andyou may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. 测试用例 输入：3,3 6输出： 0,1 输入：2,3,3 5 输出： 0,1 下面代码没有通过这个测试，但是A了。题目说结果是确定的，应该就是不考虑这种情况。 思路 先排序，最快O(nlogn)。再左右夹逼。比较暴力。 利用hash表，时间复杂度为O(n)。下面代码是基于第二种方法。 代码1234567891011121314151617vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int,int&gt; hashMap; for(int i = 0; i&lt;nums.size(); i ++) hashMap[nums[i]] = i; //cout&lt;&lt;hashMap.size()&lt;&lt;endl; vector&lt;int&gt; ans; for(int i = 0; i&lt;nums.size(); i ++)&#123; const int gap = target - nums[i]; if(hashMap[gap] &gt; 0)&#123; ans.push_back(i); ans.push_back(hashMap[gap]); break; &#125; &#125; return ans; &#125; 官方java答案123456789101112public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; return new int[] &#123; map.get(complement), i &#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException("No two sum solution"); &#125;]]></content>
      <categories>
        <category>题解</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客添加图片、音乐、视频]]></title>
    <url>%2Fhello%2F%E4%BD%A0%E5%A5%BD%EF%BC%8CHexo%2F</url>
    <content type="text"><![CDATA[1. 插入外部链接图片 1![“图片描述”](“图片地址”) 2. 添加本地图片 在\hexo\source目录下新建文件夹，命名为images或者其他你喜欢的名字，然后编辑你的md博文，插入下面的代码样式： 1![“图片描述”](/images/你的图片名字.JPG) 3. 插入音乐 比如网易云音乐，找到喜欢的歌曲，点击分享按钮，把里面的代码复制下来，直接粘贴到博文中即可 4. 插入视频 Idina Menze和Caleb Hyles激情对唱Let It Go：]]></content>
      <categories>
        <category>hello</category>
      </categories>
      <tags>
        <tag>hello</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F%E6%B5%8B%E8%AF%95%2Fhello%2Fjava%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>测试</category>
        <category>hello</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>test</tag>
      </tags>
  </entry>
</search>
