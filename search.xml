<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[牛客-北邮-哈夫曼树]]></title>
    <url>%2F%E9%A2%98%E8%A7%A3%2F%E7%89%9B%E5%AE%A2%2F%E5%8C%97%E9%82%AE%2F%E7%89%9B%E5%AE%A2-%E5%8C%97%E9%82%AE-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目描述哈夫曼树，第一行输入一个数n，表示叶结点的个数。需要用这些叶结点生成哈夫曼树，根据哈夫曼树的概念，这些结点有权值，即weight，题目需要输出所有结点的值与权值的乘积之和。 输入描述:输入有多组数据。每组第一行输入一个数n，接着输入n个叶节点（叶节点权值不超过100，2&lt;=n&lt;=1000）。 输出描述:输出权值。 示例1输入 51 2 2 5 9 输出 37 分析利用优先队列，每次找队列中最小的两个相加，之后再将和存入队列。 代码1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; Q; int n,sum =0;; cin&gt;&gt;n; for(int i = 0; i &lt; n; i ++) &#123; int t; cin&gt;&gt;t; Q.push(t); &#125; while(Q.size()&gt;1)&#123; int a,b; a = Q.top(); Q.pop(); b = Q.top(); Q.pop(); a = a+b; Q.push(a); sum += a; &#125; cout&lt;&lt;sum; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>牛客</category>
        <category>北邮</category>
      </categories>
      <tags>
        <tag>优先队列</tag>
        <tag>哈夫曼树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客-北邮-二进制]]></title>
    <url>%2F%E9%A2%98%E8%A7%A3%2F%E7%89%9B%E5%AE%A2%2F%E5%8C%97%E9%82%AE%2F%E7%89%9B%E5%AE%A2-%E5%8C%97%E9%82%AE-%E4%BA%8C%E8%BF%9B%E5%88%B6%2F</url>
    <content type="text"><![CDATA[题目描述大家都知道，数据在计算机里中存储是以二进制的形式存储的。 有一天，小明学了C语言之后，他想知道一个类型为unsigned int 类型的数字，存储在计算机中的二进制串是什么样子的。 你能帮帮小明吗？并且，小明不想要二进制串中前面的没有意义的0串，即要去掉前导0。 输入描述:每行有一个数字n（0&lt;=n&lt;=10^8），表示要求的二进制串。 输出描述:输出共T行。每行输出求得的二进制串。 示例1输入 23 输出 10111 分析数学题，除留余数。注意是倒序输出，所以用了栈，也可以不用。 代码12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; stack&lt;char&gt; s; int n,t; cin&gt;&gt;n; while(n)&#123; t = n %2; if(t) s.push('1'); else s.push('0'); n/=2; &#125; while(!s.empty())&#123; cout&lt;&lt;(s.top()); s.pop(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>牛客</category>
        <category>北邮</category>
      </categories>
      <tags>
        <tag>二进制</tag>
        <tag>数学</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_problem_4_Median_of_Two_Sorted_Arrays]]></title>
    <url>%2F%E9%A2%98%E8%A7%A3%2FLeetCode%2FLeetCode-problem-4-Median-of-Two-Sorted-Arrays%2F</url>
    <content type="text"><![CDATA[问题描述There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). 找中间数字。 例子Example 1:nums1 = [1, 3]nums2 = [2]The median is 2.0 Example 2:nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 思路 合并两个数组，然后找到中间值。这是最笨的方法。 题目没有要求输出合并后的数组，所以没必要全部比较，可以记录比较的长度，只要达到中间长度就停止。 进一步优化，不用辅助数组，试探性查找。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243 /** * 将两者不完全合并，即只要合并到len长度即可。* 用了一个辅助vector。 68ms*/ double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int len1 = nums1.size(), len2=nums2.size(); int len = (len1+len2)/2, f = (len1+len2)%2; vector&lt;int&gt; tem; double ans = 0; int i = 0, j= 0; while(i&lt;len1&amp;&amp;j&lt;len2&amp;&amp;i+j&lt;len+1)&#123; if(nums1[i]&gt;nums2[j])&#123; tem.push_back(nums2[j]); j++; &#125;else&#123; tem.push_back(nums1[i]); i++; &#125; cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;endl; &#125; while(i+j&lt;len+1)&#123; if(i&lt;len1)&#123; tem.push_back(nums1[i]); i++; &#125; if(j&lt;len2)&#123; tem.push_back(nums2[j]); j++; &#125; cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;endl; &#125; cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;" "&lt;&lt;len&lt;&lt;endl; if(f&gt;0)&#123; ans = tem[len]; &#125;else&#123; ans = double(tem[len-1]+tem[len])/2; &#125; return ans; &#125; 不用vector12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 /*** 不用vector 思路一样 但用了更长的时间 90ms*/double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int len1 = nums1.size(), len2=nums2.size(); int len = (len1+len2)/2, f = (len1+len2)%2; double ans = 0, tem = 0; int i = 0, j= 0; while(i&lt;len1&amp;&amp;j&lt;len2&amp;&amp;i+j&lt;len+1)&#123; if(nums1[i]&gt;nums2[j])&#123; if(i+j==len-1)&#123; tem = nums2[j]; &#125; if(i+j==len)&#123; ans = nums2[j]; &#125; j++; &#125;else&#123; if(i+j==len-1)&#123; tem = nums1[i]; &#125; if(i+j==len)&#123; ans = nums1[i]; &#125; i++; &#125; cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;endl; &#125; while(i+j&lt;len+1)&#123; if(i&lt;len1)&#123; if(i+j==len-1)&#123; tem = nums1[i]; &#125; if(i+j==len)&#123; ans = nums1[i]; &#125; i++; &#125; if(j&lt;len2)&#123; if(i+j==len-1)&#123; tem = nums2[j]; &#125; if(i+j==len)&#123; ans = nums2[j]; &#125; j++; &#125; cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;endl; &#125; cout&lt;&lt;i&lt;&lt;" "&lt;&lt;j&lt;&lt;" "&lt;&lt;len&lt;&lt;endl; if(f&gt;0)&#123; return ans; &#125;else&#123; return (ans+tem)/2; &#125; &#125; 进一步优化123456789101112131415161718192021222324252627282930313233343536 /*** 例程，55ms**/ double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int len1 = nums1.size(), len2=nums2.size(); if(len1&gt;len2)&#123; vector&lt;int&gt; tem = nums1; nums1 = nums2; nums2=tem; int t = len1; len1 = len2; len2 = t; &#125; int iMin = 0, iMax = len1, half = (len1+len2+1)/2; while(iMin &lt;= iMax)&#123; int i = (iMin + iMax)/2; int j = half - i; if (i &lt; iMax &amp;&amp; nums2[j-1] &gt; nums1[i])&#123; iMin = iMin + 1; // i is too small &#125; else if (i &gt; iMin &amp;&amp; nums1[i-1] &gt; nums2[j]) &#123; iMax = iMax - 1; // i is too big &#125; else &#123; // i is perfect int maxLeft = 0; if (i == 0) &#123; maxLeft =nums2[j-1]; &#125; else if (j == 0) &#123; maxLeft = nums1[i-1]; &#125; else &#123; maxLeft = max(nums1[i-1], nums2[j-1]); &#125; if ( (len1 + len2) % 2 == 1 ) &#123; return maxLeft; &#125; int minRight = 0; if (i == len1) &#123; minRight = nums2[j]; &#125; else if (j == len2) &#123; minRight = nums1[i]; &#125; else &#123; minRight = min(nums2[j], nums1[i]); &#125; return (maxLeft + minRight) / 2.0; &#125; &#125; return 0.0; &#125;]]></content>
      <categories>
        <category>题解</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
        <tag>中间数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_problem_3_Longest_Substring_Without_Repeating_Characters]]></title>
    <url>%2F%E9%A2%98%E8%A7%A3%2FLeetCode%2FLeetCode-problem-3-Longest-Substring-Without-Repeating-Characters%2F</url>
    <content type="text"><![CDATA[问题描述 Given a string, find the length of the longest substring without repeating characters. （找出最长的没有重复字母出现的子串。输出其最长长度。） 例子 Given “abcabcbb”, the answer is “abc”, which the length is 3. Given “bbbbb”, the answer is “b”, with the length of 1. Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring. 思路 有一个结论只要重复出现，index之前的东西就失去了作用，只用记录index之后的字符。 如果不是重复字符， index==-1 ,那么就让max++; 如果不是重复字符，index!=-1，就比较记录max。不能直接max++，也不能直接max=i-index; 例如：abcaad 如果出现重复，并且是在index之后出现，给记录，再比较max 如果出现重复，在index之前出现，比较记录max 测试用例&quot;abcabcss&quot; 4 &quot;aaaaa&quot; 1 &quot;qwwwejw&quot; 3 &quot;abcade&quot; 5 &quot;abba&quot; 2 index之前的就不算了 &quot;ohomm&quot; 3 &quot;tmmzuxt&quot; 5 因为t出现过，所以return的判断还是有必要的 &quot;alouzxilkaxkufsu&quot; 8 代码12345678910111213141516171819202122232425262728293031class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int index = -1; //每遇到重复值，就记录下其第一次出现的下标 int max = 0, len = s.size(); //max记录当前最长 int mapping[200] = &#123;0&#125;; int val; // 记录字符 for(int i = 0; i &lt; len; i ++)&#123; val = s[i]; //如果出现过，并且是在index之后出现，给记录 if(mapping[val]&gt;0)&#123; if(index &lt;= mapping[val]-1)&#123; index = mapping[val]-1; &#125; max = max&gt;=i-index?max:i-index; &#125; //if(index==-1) max++; // if(mapping[val]&lt;=0) &#123; if(index==-1) max++; else&#123; max = max&gt;=i-index?max:i-index; &#125; &#125; cout&lt;&lt;index&lt;&lt;" "&lt;&lt;max&lt;&lt;" "&lt;&lt;val&lt;&lt;endl; mapping[val] = i+1; &#125; if(index == -1) return max; else return max&gt;=len-index-1?max:len-index-1; &#125;&#125;; 改进版1234567891011121314 int lengthOfLongestSubstring(string s) &#123; int index = 0; //每遇到重复值，就记录下其第一次出现的下标 int max = 0, len = s.size(); //max记录当前最长 int mapping[200] = &#123;0&#125;; int val; // 记录字符 for(int i = 0; i &lt; len; i ++)&#123; val = s[i]; index = mapping[val]&gt;index?mapping[val]:index; max = max&gt;i-index+1?max:i-index+1; mapping[val] = i+1; &#125; return max; &#125; 补充ASCII码 &apos;a&apos; 97 &apos;A&apos; 65 &apos;0&apos; 48 &apos;z&apos; 122 &apos;Z&apos; 90 &apos;9&apos; 57]]></content>
      <categories>
        <category>题解</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
        <tag>最长子串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_problem_2_Add_Two_Numbers]]></title>
    <url>%2F%E9%A2%98%E8%A7%A3%2FLeetCode%2FLeetCode-problem-2-Add-Two-Numbers%2F</url>
    <content type="text"><![CDATA[问题描述You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. 假定两个数都不是0开头，除了数本身就是0。 例子Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 思路题目没什么难点，就是链表的顺序遍历问题。注意进位就行了，可能最后有一个进位要再创建一个节点，不要漏掉。 代码1234567891011121314151617181920212223242526272829303132333435363738/** * C++ 代码 * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode head(-1); int f = 0; //标识进位 ListNode* pre = &amp;head; ListNode* pa = l1, *pb = l2; int val = 0, a, b; while(pa!=nullptr||pb!=nullptr)&#123; a = pa == nullptr?0:pa-&gt;val; b = pb == nullptr?0:pb-&gt;val; val = a + b + f; f = val / 10; val = val % 10; pre-&gt;next = new ListNode(val); pa=pa==nullptr?nullptr:pa-&gt;next; pb=pb==nullptr?nullptr:pb-&gt;next; pre = pre-&gt;next; &#125; //最后判断是否有进位 if(f&gt;0)&#123; pre-&gt;next = new ListNode(f); &#125; return head.next; &#125;&#125;;]]></content>
      <categories>
        <category>题解</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode_problem_1_two_sum]]></title>
    <url>%2F%E9%A2%98%E8%A7%A3%2FLeetCode%2FLeetCode-problem-1-two-sum%2F</url>
    <content type="text"><![CDATA[Description Given an array of integers, return indices of the two numbers suchthat they add up to a specific target. You may assume that each input would have exactly one solution, andyou may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. 测试用例 输入：3,3 6输出： 0,1 输入：2,3,3 5 输出： 0,1 下面代码没有通过这个测试，但是A了。题目说结果是确定的，应该就是不考虑这种情况。 思路 先排序，最快O(nlogn)。再左右夹逼。比较暴力。 利用hash表，时间复杂度为O(n)。下面代码是基于第二种方法。 代码1234567891011121314151617vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int,int&gt; hashMap; for(int i = 0; i&lt;nums.size(); i ++) hashMap[nums[i]] = i; //cout&lt;&lt;hashMap.size()&lt;&lt;endl; vector&lt;int&gt; ans; for(int i = 0; i&lt;nums.size(); i ++)&#123; const int gap = target - nums[i]; if(hashMap[gap] &gt; 0)&#123; ans.push_back(i); ans.push_back(hashMap[gap]); break; &#125; &#125; return ans; &#125; 官方java答案123456789101112public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; return new int[] &#123; map.get(complement), i &#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException("No two sum solution"); &#125;]]></content>
      <categories>
        <category>题解</category>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客添加图片、音乐、视频]]></title>
    <url>%2Fhexo%2F%E6%B7%BB%E5%8A%A0%E8%A7%86%E9%A2%91%E9%9F%B3%E4%B9%90%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[1. 插入外部链接图片 1![“图片描述”](“图片地址”) 2. 添加本地图片 在\hexo\source目录下新建文件夹，命名为images或者其他你喜欢的名字，然后编辑你的md博文，插入下面的代码样式： 1![“图片描述”](/images/你的图片名字.JPG) 3. 插入音乐 比如网易云音乐，找到喜欢的歌曲，点击分享按钮，把里面的代码复制下来，直接粘贴到博文中即可 4. 插入视频 Idina Menze和Caleb Hyles激情对唱Let It Go：]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客配置</tag>
      </tags>
  </entry>
</search>
