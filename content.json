{"meta":{"title":"efinedxq","subtitle":"渐行渐远","description":null,"author":"efinedxq","url":"https://efinedxq.github.io"},"pages":[],"posts":[{"title":"清华-10-二叉树遍历","slug":"清华-10-二叉树遍历","date":"2018-02-02T06:46:34.000Z","updated":"2018-02-02T06:46:34.547Z","comments":true,"path":"uncategorized/清华-10-二叉树遍历/","link":"","permalink":"https://efinedxq.github.io/uncategorized/清华-10-二叉树遍历/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"清华-09-球的半径和体积","slug":"清华-09-球的半径和体积","date":"2018-02-02T06:46:18.000Z","updated":"2018-02-02T06:46:18.264Z","comments":true,"path":"uncategorized/清华-09-球的半径和体积/","link":"","permalink":"https://efinedxq.github.io/uncategorized/清华-09-球的半径和体积/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"清华-08-成绩排序","slug":"清华-08-成绩排序","date":"2018-02-02T06:45:55.000Z","updated":"2018-02-02T06:45:55.747Z","comments":true,"path":"uncategorized/清华-08-成绩排序/","link":"","permalink":"https://efinedxq.github.io/uncategorized/清华-08-成绩排序/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"清华-07-整数拆分","slug":"清华-07-整数拆分","date":"2018-02-02T06:45:42.000Z","updated":"2018-02-03T06:21:08.450Z","comments":true,"path":"题解/牛客/清华/清华-07-整数拆分/","link":"","permalink":"https://efinedxq.github.io/题解/牛客/清华/清华-07-整数拆分/","excerpt":"","text":"题目描述一个整数总可以拆分为2的幂的和，例如： 7=1+2+4 7=1+2+2+2 7=1+1+1+4 7=1+1+1+2+2 7=1+1+1+1+1+2 7=1+1+1+1+1+1+1 总共有六种不同的拆分方式。 再比如：4可以拆分成：4 = 4，4 = 1 + 1 + 1 + 1，4 = 2 + 2，4=1+1+2。 用f(n)表示n的不同拆分的种数，例如f(7)=6. 要求编写程序，读入n(不超过1000000)，输出f(n)%1000000000。 输入描述:每组输入包括一个整数：N(1&lt;=N&lt;=1000000)。 输出描述:对于每组数据，输出f(n)%1000000000。 示例1输入 7输出6 分析把数都提前算出来，之后直接输出答案。有规律，如果是奇数，那么前一个数是偶数，偶数的组合方式 代码12345678910111213//很讨巧，为啥是这样？void init(int dp[],int len)&#123; dp[0]=0;dp[1]=1;dp[2]=2; for(int i = 3; i &lt;= len; i ++) &#123; dp[i] = 0; //奇数 if(i&amp;1) &#123; dp[i] = (dp[i-1])%1000000000; &#125; else &#123; //偶数 dp[i] = (dp[i-1]+dp[i/2])%1000000000; &#125; &#125;&#125; 1234567891011121314151617181920//果然运行超时void dfs(int n, int sum,int i,int len, int &amp;cnt)&#123; if(sum==n)&#123; cnt=(cnt+1)%1000000000; return ; &#125; for(; i &lt;= len; i ++)&#123; if(sum+pow(2,i)&gt;n) return ; sum+=pow(2,i); dfs(n,sum,i,n-pow(2,i),cnt); sum-=pow(2,i); &#125;&#125;int solution(int n)&#123; int ans =0; dfs(n,0,0,n,ans); return ans;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"清华","slug":"题解/牛客/清华","permalink":"https://efinedxq.github.io/categories/题解/牛客/清华/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://efinedxq.github.io/tags/数学/"},{"name":"动态规划","slug":"动态规划","permalink":"https://efinedxq.github.io/tags/动态规划/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"清华","slug":"题解/牛客/清华","permalink":"https://efinedxq.github.io/categories/题解/牛客/清华/"}]},{"title":"清华-06-手机键盘","slug":"清华-06-手机键盘","date":"2018-02-02T06:45:25.000Z","updated":"2018-02-02T07:07:29.953Z","comments":true,"path":"题解/牛客/清华/清华-06-手机键盘/","link":"","permalink":"https://efinedxq.github.io/题解/牛客/清华/清华-06-手机键盘/","excerpt":"","text":"题目描述按照手机键盘输入字母的方式，计算所花费的时间 如：a,b,c都在“1”键上，输入a只需要按一次，输入c需要连续按三次。 如果连续两个字符不在同一个按键上，则可直接按，如：ad需要按两下，kz需要按6下 如果连续两字符在同一个按键上，则两个按键之间需要等一段时间，如ac，在按了a之后，需要等一会儿才能按c。 现在假设每按一次需要花费一个时间段，等待时间需要花费两个时间段。 现在给出一串字符，需要计算出它所需要花费的时间。 输入描述:一个长度不大于100的字符串，其中只有手机按键上有的小写字母 输出描述:输入可能包括多组数据，对于每组数据，输出按出Input所给字符串所需要的时间 示例1输入 bobwww 输出 77 分析： 记录下上次是哪个按键。 找到该字母在按键的哪个位置。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//好笨的方法。int solution(string s) &#123; int preK = 0, ans = 0; for(int i = 0; i &lt; s.length(); i ++) &#123; if(s[i]&gt;='a'&amp;&amp;s[i]&lt;='c') &#123; if(preK==2) ans+=2; if(s[i]=='a') ans++; else if(s[i]=='b') ans +=2; else ans+=3; preK = 2; &#125; else if(s[i]&gt;='d'&amp;&amp;s[i]&lt;='f') &#123; if(preK==3) ans+=2; if(s[i]=='d') ans++; else if(s[i]=='e') ans +=2; else ans+=3; preK = 3; &#125; else if(s[i]&gt;='g'&amp;&amp;s[i]&lt;='i') &#123; if(preK==4) ans+=2; if(s[i]=='g') ans++; else if(s[i]=='h') ans +=2; else ans+=3; preK = 4; &#125; else if(s[i]&gt;='j'&amp;&amp;s[i]&lt;='l') &#123; if(preK==5) ans+=2; if(s[i]=='j') ans++; else if(s[i]=='k') ans +=2; else ans+=3; preK = 5; &#125; else if(s[i]&gt;='m'&amp;&amp;s[i]&lt;='o') &#123; if(preK==6) ans+=2; if(s[i]=='m') ans++; else if(s[i]=='n') ans +=2; else ans+=3; preK = 6; &#125; else if(s[i]&gt;='p'&amp;&amp;s[i]&lt;='s') &#123; if(preK==7) ans+=2; if(s[i]=='p') ans++; else if(s[i]=='q') ans +=2; else if(s[i]=='r') ans +=3; else ans+=4; preK = 7; &#125; else if(s[i]&gt;='t'&amp;&amp;s[i]&lt;='v') &#123; if(preK==8) ans+=2; if(s[i]=='t') ans++; else if(s[i]=='u') ans +=2; else ans+=3; preK = 8; &#125; else &#123; if(preK==9) ans+=2; if(s[i]=='w') ans++; else if(s[i]=='x') ans +=2; else if(s[i]=='y') ans +=3; else ans+=4; preK = 9; &#125; &#125; return ans;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"清华","slug":"题解/牛客/清华","permalink":"https://efinedxq.github.io/categories/题解/牛客/清华/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://efinedxq.github.io/tags/字符串/"},{"name":"枚举","slug":"枚举","permalink":"https://efinedxq.github.io/tags/枚举/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"清华","slug":"题解/牛客/清华","permalink":"https://efinedxq.github.io/categories/题解/牛客/清华/"}]},{"title":"清华-05-质因数的个数","slug":"清华-05-质因数的个数","date":"2018-02-02T06:44:54.000Z","updated":"2018-02-02T07:03:58.388Z","comments":true,"path":"题解/牛客/清华/清华-05-质因数的个数/","link":"","permalink":"https://efinedxq.github.io/题解/牛客/清华/清华-05-质因数的个数/","excerpt":"","text":"题目描述求正整数N(N&gt;1)的质因数的个数。 相同的质因数需要重复计算。如120=22235，共有5个质因数。 输入描述:可能有多组测试数据，每组测试数据的输入是一个正整数N，(1&lt;N&lt;10^9)。 输出描述:对于每组数据，输出N的质因数的个数。 示例1输入120输出5 分析质因数的个数。首先看到数据是正数范围内，所以不考虑大数问题。在处理质因数的时候，一个质因数可能出现多次，所以把一个质因数消完再找下一个。 代码 未处理，超时 1234567891011121314//超时int solution(int n) &#123; int ans = 0; while(n!=1)&#123; for(int i = 2; i &lt;= n; i ++)&#123; if(n%i==0)&#123; ans++; n /= i; break; &#125; &#125; &#125; return ans;&#125; 修改后 12345678910111213//通过int solution(int n) &#123; int ans = 0; for(int i = 2; i &lt;= sqrt(n); i ++) &#123; while(n%i==0) &#123; n=n/i; ans++; &#125; if(n&lt;=1) break; &#125; if(n&gt;1) ans++; return ans;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"清华","slug":"题解/牛客/清华","permalink":"https://efinedxq.github.io/categories/题解/牛客/清华/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://efinedxq.github.io/tags/数学/"},{"name":"质因数","slug":"质因数","permalink":"https://efinedxq.github.io/tags/质因数/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"清华","slug":"题解/牛客/清华","permalink":"https://efinedxq.github.io/categories/题解/牛客/清华/"}]},{"title":"清华-04-反序输出","slug":"清华-04-反序输出","date":"2018-02-02T06:44:38.000Z","updated":"2018-02-02T06:58:07.561Z","comments":true,"path":"题解/牛客/清华/清华-04-反序输出/","link":"","permalink":"https://efinedxq.github.io/题解/牛客/清华/清华-04-反序输出/","excerpt":"","text":"题目描述输入任意4个字符(如：abcd)， 并按反序输出(如：dcba) 输入描述:题目可能包含多组用例，每组用例占一行，包含4个任意的字符。 输出描述:对于每组输入,请输出一行反序后的字符串。具体可见样例。 示例1输入 UpincvYjWJpwcXOA 输出 nipUjYvcwpJWAOXc 分析代码1只是为了AC，并没有实质性的将字符串反转过来。代码2，是临时写的，没有测试。 代码 没有实质反转 123456void solution(string s)&#123; for(int i = s.length()-1;i&gt;=0; i --)&#123; cout&lt;&lt;s[i]; &#125; cout&lt;&lt;endl;&#125; 反转12345void solution(string s)&#123; for(int i = s.length()-1, j=0;j&lt;i; i --,j++)&#123; swap(s[i],s[j]); &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"清华","slug":"题解/牛客/清华","permalink":"https://efinedxq.github.io/categories/题解/牛客/清华/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://efinedxq.github.io/tags/字符串/"},{"name":"反序","slug":"反序","permalink":"https://efinedxq.github.io/tags/反序/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"清华","slug":"题解/牛客/清华","permalink":"https://efinedxq.github.io/categories/题解/牛客/清华/"}]},{"title":"清华-03-代理服务器","slug":"清华-03-代理服务器","date":"2018-02-02T06:44:15.000Z","updated":"2018-02-02T06:50:49.979Z","comments":true,"path":"题解/牛客/清华/清华-03-代理服务器/","link":"","permalink":"https://efinedxq.github.io/题解/牛客/清华/清华-03-代理服务器/","excerpt":"","text":"题目描述使用代理服务器能够在一定程度上隐藏客户端信息，从而保护用户在互联网上的隐私。我们知道n个代理服务器的IP地址，现在要用它们去访问m个服务器。这 m 个服务器的 IP 地址和访问顺序也已经给出。系统在同一时刻只能使用一个代理服务器，并要求不能用代理服务器去访问和它 IP地址相同的服务器（不然客户端信息很有可能就会被泄露）。在这样的条件下，找到一种使用代理服务器的方案，使得代理服务器切换的次数尽可能得少。 输入描述: 每个测试数据包括 n + m + 2 行。 第 1 行只包含一个整数 n，表示代理服务器的个数。 第 2行至第n + 1行每行是一个字符串，表示代理服务器的 IP地址。这n个 IP地址两两不相同。 第 n + 2 行只包含一个整数 m，表示要访问的服务器的个数。 第 n + 3 行至第 n + m + 2 行每行是一个字符串，表示要访问的服务器的 IP 地址，按照访问的顺序给出。 每个字符串都是合法的IP地址，形式为“xxx.yyy.zzz.www”，其中任何一部分均是0–255之间的整数。输入数据的任何一行都不包含空格字符。 其中，1&lt;=n&lt;=1000，1&lt;=m&lt;=5000。 输出描述:可能有多组测试数据，对于每组输入数据， 输出数据只有一行，包含一个整数s，表示按照要求访问服务器的过程中切换代理服务器的最少次数。第一次使用的代理服务器不计入切换次数中。若没有符合要求的安排方式，则输出-1。 示例1输入 3166.111.4.100162.105.131.113202.112.128.69672.14.235.104166.111.4.100207.46.19.190202.112.128.69162.105.131.113118.214.226.52 输出 1 分析枚举，每次找到能达到要求最长的代理IP，并记下这时服务IP位置，作为下一次搜索的开始，如此反复枚举，直到遍历完服务IP为止。其中注意点，n为1且不能达到要求时，返回-1；达到最后一个服务IP时返回0。 代码1234567891011121314int solution(int n, string pox[], int m, string svr[])&#123; int len = -1; for(int i = 0,j; i &lt; n; i ++)&#123; for(j = 0; j &lt; m; j ++)&#123; if(pox[i]==svr[j])&#123; len = j &gt; len?j:len; break; &#125; &#125; if(j==m) return 0; &#125; if(n==1&amp;&amp;len!=-1) return -1; return 1+solution(n,pox,m-len,svr+len);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"清华","slug":"题解/牛客/清华","permalink":"https://efinedxq.github.io/categories/题解/牛客/清华/"}],"tags":[{"name":"枚举","slug":"枚举","permalink":"https://efinedxq.github.io/tags/枚举/"},{"name":"递归","slug":"递归","permalink":"https://efinedxq.github.io/tags/递归/"},{"name":"暴力","slug":"暴力","permalink":"https://efinedxq.github.io/tags/暴力/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"清华","slug":"题解/牛客/清华","permalink":"https://efinedxq.github.io/categories/题解/牛客/清华/"}]},{"title":"牛客-清华-02-约数的个数","slug":"牛客-清华-02-约数的个数","date":"2018-01-28T07:11:43.000Z","updated":"2018-01-28T07:23:54.624Z","comments":true,"path":"题解/牛客/清华/牛客-清华-02-约数的个数/","link":"","permalink":"https://efinedxq.github.io/题解/牛客/清华/牛客-清华-02-约数的个数/","excerpt":"","text":"题目描述输入n个整数,依次输出每个数的约数的个数 输入描述:输入的第一行为N，即数组的个数(N&lt;=1000)接下来的1行包括N个整数，其中每个数的范围为(1&lt;=Num&lt;=1000000000)当N=0时输入结束。 输出描述:可能有多组输入数据，对于每组输入数据，输出N行，其中每一行对应上面的一个数的约数的个数。 示例1输入 51 3 4 6 12 输出 12346 代码12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main() &#123; int n, m; while(cin&gt;&gt;n) &#123; while(n--) &#123; int cnt = 0; cin&gt;&gt;m; for(int i = 1; i &lt;= sqrt(m); i++) &#123; int a = m%i; if(a==0) &#123; if(i*i==m) cnt++; else cnt+=2; &#125; &#125; cout&lt;&lt;cnt&lt;&lt;endl; &#125; &#125; return 0;&#125; 其中循环部分还可以这么写 1234567cin&gt;&gt;m;for(i = 1; i*i &lt; m; i++) &#123; if(m%i==0) &#123; cnt+=2; &#125;&#125;if(i*i==m) cnt++;","categories":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"清华","slug":"题解/牛客/清华","permalink":"https://efinedxq.github.io/categories/题解/牛客/清华/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://efinedxq.github.io/tags/数组/"},{"name":"数学","slug":"数学","permalink":"https://efinedxq.github.io/tags/数学/"},{"name":"约数","slug":"约数","permalink":"https://efinedxq.github.io/tags/约数/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"清华","slug":"题解/牛客/清华","permalink":"https://efinedxq.github.io/categories/题解/牛客/清华/"}]},{"title":"牛客-清华-01-成绩排序","slug":"牛客-清华-01-成绩排序","date":"2018-01-28T07:11:23.000Z","updated":"2018-01-28T07:21:04.623Z","comments":true,"path":"题解/牛客/清华/牛客-清华-01-成绩排序/","link":"","permalink":"https://efinedxq.github.io/题解/牛客/清华/牛客-清华-01-成绩排序/","excerpt":"","text":"问题描述输入任意（用户，成绩）序列，可以获得成绩从高到低或从低到高的排列,相同成绩都按先录入排列在前的规则处理。 例示：输入： jack 70 peter 96 Tom 70 smith 67 输出： 从高到低 成绩 peter 96jack 70Tom 70smith 67 从低到高 smith 67Tom 70jack 70peter 96 输入描述:输入多行，先输入要排序的人的个数，然后输入排序方法0（降序）或者1（升序）再分别输入他们的名字和成绩，以一个空格隔开 输出描述:按照指定方式输出名字和成绩，名字和成绩之间以一个空格隔开 示例1输入 30fang 90yang 50ning 70 输出 fang 90ning 70yang 50 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//错误代码#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;struct Node &#123; string name; float scor;&#125;;/*** 升序*/int cmpASC(const void *c,const void *d) &#123; Node a = *(Node*)c; Node b = *(Node*)d; return a.scor &gt;= b.scor;&#125;/*** 降序*/int cmpDES(const void *c,const void *d) &#123; Node a = *(Node*)c; Node b = *(Node*)d; return a.scor &lt;= b.scor;&#125;int main() &#123; int n, m; cin&gt;&gt;n; cin&gt;&gt;m; Node node[n]; for(int i = 0; i &lt; n; i ++) &#123; string s; float a; cin&gt;&gt;s&gt;&gt;a; node[i].name = s; node[i].scor = a; &#125; if(m==0) &#123; qsort(node,n,sizeof(node[0]),cmpDES); &#125; else &#123; qsort(node,n,sizeof(node[0]),cmpASC); &#125; for(int i = 0; i &lt; n; i ++) &#123; cout&lt;&lt;node[i].name&lt;&lt;\" \"&lt;&lt;node[i].scor&lt;&lt;endl; &#125; return 0;&#125; 上边代码，不知道哪里出错，oj上提示指针溢出。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/**** 直接插入排序，ac*/#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;struct Node &#123; string name; float scor;&#125; stu[1000];int main() &#123; int n, m; while(cin&gt;&gt;n) &#123; cin&gt;&gt;m; for(int i = 0; i &lt; n; i ++) &#123; string s; float a; cin&gt;&gt;s&gt;&gt;a; stu[i].name = s; stu[i].scor = a; &#125; if(m==0) &#123; //降序 Node tem; for(int i = 1,j; i &lt; n; i ++) &#123; tem = stu[i]; for(j = i; j&gt;0&amp;&amp; stu[j-1].scor&lt;tem.scor; j--) &#123; stu[j] = stu[j-1]; &#125; stu[j] = tem; &#125; &#125; else &#123; //升序 Node tem; for(int i = 1,j; i &lt; n; i ++) &#123; tem = stu[i]; for(j = i; j&gt;0&amp;&amp; stu[j-1].scor&gt;tem.scor; j--) &#123; stu[j] = stu[j-1]; &#125; stu[j] = tem; &#125; &#125; for(int i = 0; i &lt; n; i ++) &#123; cout&lt;&lt;stu[i].name&lt;&lt;\" \"&lt;&lt;stu[i].scor&lt;&lt;endl; &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"清华","slug":"题解/牛客/清华","permalink":"https://efinedxq.github.io/categories/题解/牛客/清华/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://efinedxq.github.io/tags/排序/"},{"name":"结构体","slug":"结构体","permalink":"https://efinedxq.github.io/tags/结构体/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"清华","slug":"题解/牛客/清华","permalink":"https://efinedxq.github.io/categories/题解/牛客/清华/"}]},{"title":"牛客-北邮-复数集合","slug":"牛客-北邮-复数集合","date":"2018-01-28T06:44:33.000Z","updated":"2018-01-30T01:38:05.387Z","comments":true,"path":"题解/牛客/北邮/牛客-北邮-复数集合/","link":"","permalink":"https://efinedxq.github.io/题解/牛客/北邮/牛客-北邮-复数集合/","excerpt":"","text":"题目描述一个复数（x+iy）集合，两种操作作用在该集合上： 1、Pop 表示读出集合中复数模值最大的那个复数，如集合为空 输出 empty ，不为空就输出最大的那个复数并且从集合中删除那个复数，再输出集合的大小SIZE； 2 Insert a+ib 指令（a，b表示实部和虚部），将a+ib加入到集合中 ，输出集合的大小SIZE； 最开始要读入一个int n，表示接下来的n行每一行都是一条命令。 输入描述:输入有多组数据。每组输入一个n(1&lt;=n&lt;=1000)，然后再输入n条指令。 输出描述:根据指令输出结果。模相等的输出b较小的复数。a和b都是非负数。 示例1输入 3PopInsert 1+i2Pop 输出 emptySIZE = 11+i2SIZE = 0 分析处理字符串，关于字符串，cstring 和 string 是不一样的。用cin输入的字符串，就要用string库函数，输出也要用cout，是对应的；不然会出错。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;cstdio&gt;#include &lt;string&gt;using namespace std;class Node&#123; public: int a; int b; float mode; public: bool operator&lt;(const Node&amp; rhs) const&#123; return this-&gt;mode&lt;rhs.mode; &#125;&#125;;int main() &#123; int n; string t, c; priority_queue&lt;Node&gt; numQ; cin&gt;&gt;n; while(n--)&#123; cin&gt;&gt;t; if(!t.compare(\"Pop\"))&#123; if(numQ.empty())&#123; cout&lt;&lt;\"empty\"&lt;&lt;endl; &#125;else&#123; Node num = numQ.top(); numQ.pop(); cout&lt;&lt;num.a&lt;&lt;\"+i\"&lt;&lt;num.b&lt;&lt;endl; cout&lt;&lt;\"SIZE = \"&lt;&lt;numQ.size()&lt;&lt;endl; &#125; &#125;else&#123; Node num; int a =0, b =0; scanf(\"%d+i%d\",&amp;a,&amp;b); num.a = a; num.b = b; num.mode = sqrt(a*a+b*b); numQ.push(num); cout&lt;&lt;\"SIZE = \"&lt;&lt;numQ.size()&lt;&lt;endl; &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"北邮","slug":"题解/牛客/北邮","permalink":"https://efinedxq.github.io/categories/题解/牛客/北邮/"}],"tags":[{"name":"优先队列","slug":"优先队列","permalink":"https://efinedxq.github.io/tags/优先队列/"},{"name":"数学","slug":"数学","permalink":"https://efinedxq.github.io/tags/数学/"},{"name":"复数","slug":"复数","permalink":"https://efinedxq.github.io/tags/复数/"},{"name":"类排序","slug":"类排序","permalink":"https://efinedxq.github.io/tags/类排序/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"北邮","slug":"题解/牛客/北邮","permalink":"https://efinedxq.github.io/categories/题解/牛客/北邮/"}]},{"title":"牛客-北邮-找最小数","slug":"牛客-北邮-找最小数","date":"2018-01-28T06:44:18.000Z","updated":"2018-01-28T07:03:16.492Z","comments":true,"path":"题解/牛客/北邮/牛客-北邮-找最小数/","link":"","permalink":"https://efinedxq.github.io/题解/牛客/北邮/牛客-北邮-找最小数/","excerpt":"","text":"题目描述第一行输入一个数n，1 &lt;= n &lt;= 1000，下面输入n行数据，每一行有两个数，分别是x y。输出一组x y，该组数据是所有数据中x最小，且在x相等的情况下y最小的。 输入描述:输入有多组数据。每组输入n，然后输入n个整数对。 输出描述:输出最小的整数对。 示例1输入 53 32 25 52 13 6 输出 2 1 分析开始想用结构体把数先存下来再做比较，觉得结构体排序有点繁琐。观察题目再没有别的要求，于是就没有把数存都存下来，只存了最大。输入完结果也就出来了。 代码1234567891011121314151617181920212223#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int main() &#123; int n; while(scanf(\"%d\",&amp;n)!=EOF)&#123; int a, b, ansA,ansB; scanf(\"%d%d\",&amp;ansA,&amp;ansB); for(int i = 1; i &lt; n; i ++)&#123; scanf(\"%d%d\",&amp;a,&amp;b); if(a&lt;ansA)&#123; ansA = a; ansB = b; &#125; if(a==ansA&amp;&amp;b&lt;ansB)&#123; ansB = b; &#125; &#125; printf(\"%d %d\\n\",ansA,ansB); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"北邮","slug":"题解/牛客/北邮","permalink":"https://efinedxq.github.io/categories/题解/牛客/北邮/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://efinedxq.github.io/tags/数组/"},{"name":"比较查找","slug":"比较查找","permalink":"https://efinedxq.github.io/tags/比较查找/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"北邮","slug":"题解/牛客/北邮","permalink":"https://efinedxq.github.io/categories/题解/牛客/北邮/"}]},{"title":"牛客-北邮-查找2","slug":"牛客-北邮-查找2","date":"2018-01-28T06:43:57.000Z","updated":"2018-01-28T11:06:22.759Z","comments":true,"path":"题解/牛客/北邮/牛客-北邮-查找2/","link":"","permalink":"https://efinedxq.github.io/题解/牛客/北邮/牛客-北邮-查找2/","excerpt":"","text":"题目描述输入数组长度 n 输入数组 a[1…n] 输入查找个数m 输入查找数字b[1…m] 输出 YES or NO 查找有则YES 否则NO 。 输入描述:输入有多组数据。每组输入n，然后输入n个整数，再输入m，然后再输入m个整数（1&lt;=m,n&lt;=100）。 输出描述:如果在n个数组中输出YES否则输出NO。 示例1输入 51 5 2 4 332 5 6 输出 YESYESNO 分析利用Map，时间查找一个数时间复杂度O(1) 代码12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;map&gt;using namespace std;int main() &#123; int n, m, a,b; map&lt;int,bool&gt; hashMap; while(scanf(\"%d\",&amp;n)!=EOF)&#123; for(int i = 0; i &lt; n; i ++)&#123; scanf(\"%d\",&amp;a); hashMap[a] = 1; &#125; scanf(\"%d\",&amp;m); while(m--)&#123; scanf(\"%d\",&amp;b); if(hashMap[b])&#123; printf(\"YES\\n\"); &#125;else&#123; printf(\"NO\\n\"); &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"北邮","slug":"题解/牛客/北邮","permalink":"https://efinedxq.github.io/categories/题解/牛客/北邮/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://efinedxq.github.io/tags/数组/"},{"name":"查找","slug":"查找","permalink":"https://efinedxq.github.io/tags/查找/"},{"name":"map","slug":"map","permalink":"https://efinedxq.github.io/tags/map/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"北邮","slug":"题解/牛客/北邮","permalink":"https://efinedxq.github.io/categories/题解/牛客/北邮/"}]},{"title":"牛客-北邮-查找","slug":"牛客-北邮-查找","date":"2018-01-28T06:43:48.000Z","updated":"2018-01-28T06:59:56.214Z","comments":true,"path":"题解/牛客/北邮/牛客-北邮-查找/","link":"","permalink":"https://efinedxq.github.io/题解/牛客/北邮/牛客-北邮-查找/","excerpt":"","text":"题目描述读入一组字符串（待操作的），再读入一个int n记录记下来有几条命令，总共有2中命令：1、翻转 从下标为i的字符开始到i+len-1之间的字符串倒序；2、替换 命中如果第一位为1，用命令的第四位开始到最后的字符串替换原读入的字符串下标 i 到 i+len-1的字符串。每次执行一条命令后新的字符串代替旧的字符串（即下一条命令在作用在得到的新字符串上）。 命令格式：第一位0代表翻转，1代表替换；第二位代表待操作的字符串的起始下标int i；第三位表示需要操作的字符串长度int len。 输入描述:输入有多组数据。每组输入一个字符串（不大于100）然后输入n，再输入n条指令（指令一定有效）。 输出描述:根据指令对字符串操作后输出结果。 示例1输入 bac2003112as 输出 cabcas 分析 字符串反转，字符串替换 要读懂题意，替换是指，整个从i到i+len-1，替换成第四位后边的串，不管长度是否一致。比如：abcd，中b替换成hjkl，就成了ahjklcd。 代码123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cmath&gt;using namespace std;int main() &#123; string s; int n; vector&lt;string&gt; commens; cin&gt;&gt;s&gt;&gt;n; for(int i = 0; i &lt; n; i ++) &#123; string cm; cin&gt;&gt;cm; commens.push_back(cm); &#125; for(int i = 0; i &lt; commens.size(); i ++)&#123; string t = commens[i]; if(t[0]=='0')&#123; for(int j = t[1]-'0', k = t[1]-'0'+t[2]-'0'-1; j &lt; k; j++,k--)&#123; char ch = s[j]; s[j] = s[k]; s[k] = ch; &#125; &#125;else&#123; int start = t[1] - '0', len = t[2]-'0'; t.erase(0,3); s.replace(start,len,t); &#125; cout&lt;&lt;s&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"北邮","slug":"题解/牛客/北邮","permalink":"https://efinedxq.github.io/categories/题解/牛客/北邮/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://efinedxq.github.io/tags/字符串/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"北邮","slug":"题解/牛客/北邮","permalink":"https://efinedxq.github.io/categories/题解/牛客/北邮/"}]},{"title":"牛客-北邮-二叉排序树","slug":"牛客-北邮-二叉排序树","date":"2018-01-28T06:36:13.000Z","updated":"2018-01-28T06:49:28.186Z","comments":true,"path":"题解/牛客/北邮/牛客-北邮-二叉排序树/","link":"","permalink":"https://efinedxq.github.io/题解/牛客/北邮/牛客-北邮-二叉排序树/","excerpt":"","text":"题目描述输入一系列整数，建立二叉排序数，并进行前序，中序，后序遍历。 输入描述:输入第一行包括一个整数n(1&lt;=n&lt;=100)。接下来的一行包括n个整数。 输出描述:可能有多组测试数据，对于每组数据，将题目所给数据建立一个二叉排序树，并对二叉排序树进行前序、中序和后序遍历。每种遍历结果输出一行。每行最后一个数据之后有一个空格。 输入中可能有重复元素，但是输出的二叉树遍历序列中重复元素不用输出。 示例1输入 51 6 5 9 8 输出 1 6 5 9 81 5 6 8 95 8 9 6 1 分析注意点： 1.知道结构体及指针的基本使用方法 2.用while(scanf()!=EOF)作为输入！ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Tree &#123; int data; struct Tree *left, *right;&#125; BiTNode,BiTree;BiTree* Insert(BiTree* t, int tem) &#123; if(t==NULL) &#123; t = (BiTNode*)malloc(sizeof(BiTNode)); t-&gt;data = tem; t-&gt;left = t-&gt;right = NULL; &#125; else if(tem &lt; t-&gt;data) &#123; t-&gt;left = Insert(t-&gt;left,tem); &#125; else if(tem &gt; t-&gt;data) &#123; t-&gt;right = Insert(t-&gt;right,tem); &#125; return t;&#125;/*** 先序遍历 中左右*/void outP(BiTree* t) &#123; printf(\"%d \",t-&gt;data); if(t-&gt;left!=NULL) &#123; outP(t-&gt;left); &#125; if(t-&gt;right!=NULL) &#123; outP(t-&gt;right); &#125;&#125;/*** 中序遍历 左中右*/void outM(BiTree* t) &#123; if(t-&gt;left) &#123; outM(t-&gt;left); &#125; //cout&lt;&lt;t-&gt;data&lt;&lt;\" \"; printf(\"%d \",t-&gt;data); if(t-&gt;right) &#123; outM(t-&gt;right); &#125;&#125;/*** 后序遍历 左右中*/void outE(BiTree* t) &#123; if(t-&gt;left) &#123; outE(t-&gt;left); &#125; if(t-&gt;right) &#123; outE(t-&gt;right); &#125; printf(\"%d \",t-&gt;data);&#125;int main() &#123; int n,tem,i; BiTree *T = NULL; while(scanf(\"%d\",&amp;n)!=EOF) &#123; T = NULL; for( i = 0; i&lt;n; i ++) &#123; //cin&gt;&gt;tem; scanf(\"%d\",&amp;tem); T = Insert(T,tem); &#125; outP(T); printf(\"\\n\"); outM(T); printf(\"\\n\"); outE(T); printf(\"\\n\"); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"北邮","slug":"题解/牛客/北邮","permalink":"https://efinedxq.github.io/categories/题解/牛客/北邮/"}],"tags":[{"name":"二叉排序树","slug":"二叉排序树","permalink":"https://efinedxq.github.io/tags/二叉排序树/"},{"name":"结构体","slug":"结构体","permalink":"https://efinedxq.github.io/tags/结构体/"},{"name":"指针","slug":"指针","permalink":"https://efinedxq.github.io/tags/指针/"},{"name":"树遍历","slug":"树遍历","permalink":"https://efinedxq.github.io/tags/树遍历/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"北邮","slug":"题解/牛客/北邮","permalink":"https://efinedxq.github.io/categories/题解/牛客/北邮/"}]},{"title":"牛客-北邮-树查找","slug":"牛客-北邮-树查找","date":"2018-01-26T13:42:24.000Z","updated":"2018-01-26T14:08:33.433Z","comments":true,"path":"题解/牛客/北邮/牛客-北邮-树查找/","link":"","permalink":"https://efinedxq.github.io/题解/牛客/北邮/牛客-北邮-树查找/","excerpt":"","text":"题目描述有一棵树，输出某一深度的所有节点，有则输出这些节点，无则输出EMPTY。该树是完全二叉树。 输入描述:输入有多组数据。每组输入一个n(1&lt;=n&lt;=1000)，然后将树中的这n个节点依次输入，再输入一个d代表深度。 输出描述:输出该树中第d层得所有节点，节点间用空格隔开，最后一个节点后没有空格。 示例1输入 41 2 3 42 输出 2 3 分析 深度为1，起点为1；深度为2，起点为2；深度为3，起点为4… 推出深度为d，起点为pow(2,d-1); 这更像一道数学规律题。 代码12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cmath&gt;using namespace std;int main() &#123; int n, d; vector&lt;int&gt; num; cin&gt;&gt;n; num.push_back(0); for(int i = 0; i &lt; n; i ++) &#123; int a; cin&gt;&gt;a; num.push_back(a); &#125; cin&gt;&gt;d; if(pow(2,d-1)&gt;=num.size()) &#123; cout&lt;&lt;\"EMPTY\"&lt;&lt;endl; &#125; else &#123; for(int i = pow(2,d-1); i&lt;num.size()&amp;&amp;i&lt;pow(2,d); i++) &#123; cout&lt;&lt;num[i]; if(i&lt;num.size()-1&amp;&amp;i&lt;pow(2,d)-1) &#123; cout&lt;&lt;\" \"; &#125; else &#123; cout&lt;&lt;endl; &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"北邮","slug":"题解/牛客/北邮","permalink":"https://efinedxq.github.io/categories/题解/牛客/北邮/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://efinedxq.github.io/tags/数组/"},{"name":"二叉树","slug":"二叉树","permalink":"https://efinedxq.github.io/tags/二叉树/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"北邮","slug":"题解/牛客/北邮","permalink":"https://efinedxq.github.io/categories/题解/牛客/北邮/"}]},{"title":"牛客-北邮-打牌","slug":"牛客-北邮-打牌","date":"2018-01-26T13:42:09.000Z","updated":"2018-01-26T14:05:12.873Z","comments":true,"path":"题解/牛客/北邮/牛客-北邮-打牌/","link":"","permalink":"https://efinedxq.github.io/题解/牛客/北邮/牛客-北邮-打牌/","excerpt":"","text":"题目描述牌只有1到9，手里拿着已经排好序的牌a，对方出牌b，用程序判断手中牌是否能够压过对方出牌。 规则：出牌牌型有5种 [1]一张 如4 则5…9可压过 [2]两张 如44 则55，66，77，…，99可压过 [3]三张 如444 规则如[2] [4]四张 如4444 规则如[2] [5]五张 牌型只有12345 23456 34567 45678 56789五个，后面的比前面的均大。 输入描述:输入有多组数据。每组输入两个字符串(字符串大小不超过100)a，b。a字符串代表手中牌，b字符串代表处的牌。 输出描述:压过输出YES 否则NO。 示例1输入 1223344556667733 输出 YES 分析按照规则，分为两种况:一种是顺子，一种就是重复。 顺子时候。先将a串去重复。然后再初步判断第一张牌是否大于，大于时，再比较后四张牌。 重复。判断第一张牌是否大于，大于时，再比较b.length()长度的牌。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;int main()&#123; string a, b, c; bool flags = false; cin&gt;&gt;a&gt;&gt;b; if(b.length()&lt;5&amp;&amp;b.length()&gt;0) &#123; for(int i = 0; i &lt; a.length()-b.length()+1;i ++)&#123; if(a[i]&gt;b[0])&#123; for(int j = i; j &lt;= i+b.length()-1; j ++)&#123; if(a[j]&gt;b[0]&amp;&amp;a[j]==a[i])&#123; flags = true; &#125;else &#123; flags = false; break; &#125; &#125; if(flags) break; &#125; &#125; &#125;else&#123; for(int i = 1;i &lt; a.length(); i ++)&#123; if(a[i]==a[i-1])&#123; a.erase(i,1); i--; &#125; &#125; for(int i = 0; i &lt; a.length(); i ++)&#123; if(a[i]&gt;b[0])&#123; for(int j = 1; j &lt; b.length(); j ++)&#123; if(a[i+j]&gt;b[j]&amp;&amp;a[i+j]-a[i+j-1]==1)&#123; flags = true; &#125; else &#123; flags = false; break; &#125; &#125; &#125; if(flags) break; &#125; &#125; if(flags) cout&lt;&lt;\"YES\"; else cout&lt;&lt;\"NO\"; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"北邮","slug":"题解/牛客/北邮","permalink":"https://efinedxq.github.io/categories/题解/牛客/北邮/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://efinedxq.github.io/tags/数组/"},{"name":"数学","slug":"数学","permalink":"https://efinedxq.github.io/tags/数学/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"北邮","slug":"题解/牛客/北邮","permalink":"https://efinedxq.github.io/categories/题解/牛客/北邮/"}]},{"title":"牛客-北邮-C反转","slug":"牛客-北邮-C反转","date":"2018-01-26T13:41:58.000Z","updated":"2018-01-26T13:56:49.026Z","comments":true,"path":"题解/牛客/北邮/牛客-北邮-C反转/","link":"","permalink":"https://efinedxq.github.io/题解/牛客/北邮/牛客-北邮-C反转/","excerpt":"","text":"题目描述首先输入一个5 * 5的数组，然后输入一行，这一行有四个数，前两个代表操作类型，后两个数x y代表需操作数据为以x y为左上角的那几个数据。 操作类型有四种： 1 2 表示：90度，顺时针，翻转4个数 1 3 表示：90度，顺时针，翻转9个数 2 2 表示：90度，逆时针，翻转4个数 2 3 表示：90度，逆时针，翻转9个数 输入描述:输入有多组数据。每组输入一个5 * 5的数组，然后输入一行，这一行有四个数，前两个代表操作类型，后两个数x y代表需操作数据为以x y为左上角的那几个数据。 输出描述:输出翻转后的数组。 示例1输入 1 2 3 4 56 7 8 9 1011 12 13 14 1516 17 18 19 2021 22 23 24 251 3 1 1 输出 11 6 1 4 512 7 2 9 1013 8 3 14 1516 17 18 19 2021 22 23 24 25 分析用的方法比较笨，比较暴力，挨个交换。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;int main()&#123; int num[6][6], n, m, x, y; for(int i = 1; i &lt;=5; i ++ ) for(int j = 1; j &lt;= 5; j ++) cin&gt;&gt;num[i][j]; cin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;y; if(n==1&amp;&amp;m==2)&#123; int tem = num[x][y]; num[x][y] = num[x+1][y]; num[x+1][y] = num[x+1][y+1]; num[x+1][y+1] = num[x][y+1]; num[x][y+1] = tem; &#125;else if(n==1&amp;&amp;m==3)&#123; int tem = num[x][y]; num[x][y] = num[x+2][y]; num[x+2][y] = num[x+2][y+2]; num[x+2][y+2] = num[x][y+2]; num[x][y+2] = tem; tem = num[x][y+1]; num[x][y+1] = num[x+1][y]; num[x+1][y] = num[x+2][y+1]; num[x+2][y+1] = num[x+1][y+2]; num[x+1][y+2] = tem; &#125;else if(n==2&amp;&amp;m==2)&#123; int tem = num[x][y]; num[x][y] = num[x][y+1]; num[x][y+1] = num[x+1][y+1]; num[x+1][y+1] = num[x+1][y]; num[x+1][y] = tem; &#125;else if(n==2&amp;&amp;m==3)&#123; int tem = num[x][y]; num[x][y] = num[x][y+2]; num[x][y+2] = num[x+2][y+2]; num[x+2][y+2] = num[x+2][y]; num[x+2][y] = tem; tem = num[x][y+1]; num[x][y+1] = num[x+1][y+2]; num[x+1][y+2] = num[x+2][y+1]; num[x+2][y+1] = num[x+1][y]; num[x+1][y] = tem; &#125; for(int i = 1; i &lt;= 5;i ++)&#123; for(int j = 1; j &lt;= 5; j ++)&#123; cout&lt;&lt;num[i][j]; if(j==5) cout&lt;&lt;endl; else cout&lt;&lt;\" \"; &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"北邮","slug":"题解/牛客/北邮","permalink":"https://efinedxq.github.io/categories/题解/牛客/北邮/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://efinedxq.github.io/tags/数组/"},{"name":"数学","slug":"数学","permalink":"https://efinedxq.github.io/tags/数学/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"北邮","slug":"题解/牛客/北邮","permalink":"https://efinedxq.github.io/categories/题解/牛客/北邮/"}]},{"title":"牛客-北邮-矩阵幂","slug":"牛客-北邮-矩阵幂","date":"2018-01-26T13:41:45.000Z","updated":"2018-01-26T13:53:46.095Z","comments":true,"path":"题解/牛客/北邮/牛客-北邮-矩阵幂/","link":"","permalink":"https://efinedxq.github.io/题解/牛客/北邮/牛客-北邮-矩阵幂/","excerpt":"","text":"题目描述给定一个n*n的矩阵，求该矩阵的k次幂，即P^k。 输入描述:第一行：两个整数n（2&lt;=n&lt;=10）、k（1&lt;=k&lt;=5），两个数字之间用一个空格隔开，含义如上所示。接下来有n行，每行n个正整数，其中，第i行第j个整数表示矩阵中第i行第j列的矩阵元素Pij且（0&lt;=Pij&lt;=10）。另外，数据保证最后结果不会超过10^8。 输出描述:对于每组测试数据，输出其结果。格式为：n行n列个整数，每行数之间用空格隔开，注意，每行最后一个数后面不应该有多余的空格。 示例1输入 2 29 89 3输出153 96108 81 分析矩阵相乘，第i行乘以j列 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;/*** 矩阵相乘，第a行乘以b列*/int solut(int tem[10][10], int num[10][10], int a, int b, int n) &#123; int ans = 0; for(int i = 0; i &lt; n; i ++) &#123; ans += tem[a][i]*num[i][b]; &#125; return ans;&#125;int main() &#123; int n, m,num[10][10],tem[10][10],ans[10][10]; cin&gt;&gt;n&gt;&gt;m; for(int i = 0; i &lt; n; i ++) for(int j = 0; j &lt; n; j++) &#123; cin&gt;&gt;num[i][j]; ans[i][j] = num[i][j]; &#125; //计算 for(int i = 1; i &lt; m; i ++) &#123; for(int j = 0; j &lt; n; j ++)&#123; for(int k = 0;k &lt; n; k ++)&#123; tem[j][k] = ans[j][k]; &#125; &#125; //矩阵相乘 for(int j = 0; j &lt; n; j ++) &#123; for(int k = 0; k &lt; n; k ++) &#123; ans[j][k] = solut(tem,num,j,k,n); &#125; &#125; &#125; //输出 for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; cout&lt;&lt;ans[i][j]; if(j==n-1) &#123; cout&lt;&lt;endl; &#125; else &#123; cout&lt;&lt;\" \"; &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"北邮","slug":"题解/牛客/北邮","permalink":"https://efinedxq.github.io/categories/题解/牛客/北邮/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://efinedxq.github.io/tags/数学/"},{"name":"矩阵","slug":"矩阵","permalink":"https://efinedxq.github.io/tags/矩阵/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"北邮","slug":"题解/牛客/北邮","permalink":"https://efinedxq.github.io/categories/题解/牛客/北邮/"}]},{"title":"牛客-北邮-查找第K小数","slug":"牛客-北邮-查找第K小数","date":"2018-01-26T13:41:23.000Z","updated":"2018-01-26T13:49:50.155Z","comments":true,"path":"题解/牛客/北邮/牛客-北邮-查找第K小数/","link":"","permalink":"https://efinedxq.github.io/题解/牛客/北邮/牛客-北邮-查找第K小数/","excerpt":"","text":"题目描述查找一个数组的第K小的数，注意同样大小算一样大。 如 2 1 3 4 5 2 第三小数为3。 输入描述:输入有多组数据。每组输入n，然后输入n个整数(1&lt;=n&lt;=1000)，再输入k。 输出描述:输出第k小的整数。 示例1输入 62 1 3 5 2 23输出3 分析先排序，然后遍历数组计数查找。 代码123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int n, m,num[1000],cnt=1,ans; cin&gt;&gt;n; for(int i = 0; i &lt; n; i ++) &#123; cin&gt;&gt;num[i]; &#125; cin&gt;&gt;m; sort(num,num+n); if(m==1) &#123; cout&lt;&lt;num[0]; &#125; else for(int i = 1; i &lt; n; i ++) &#123; if(num[i]!=num[i-1]) cnt++; if(cnt==m) &#123; cout&lt;&lt;num[i]; break; &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"北邮","slug":"题解/牛客/北邮","permalink":"https://efinedxq.github.io/categories/题解/牛客/北邮/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://efinedxq.github.io/tags/数组/"},{"name":"排序","slug":"排序","permalink":"https://efinedxq.github.io/tags/排序/"},{"name":"查找","slug":"查找","permalink":"https://efinedxq.github.io/tags/查找/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"北邮","slug":"题解/牛客/北邮","permalink":"https://efinedxq.github.io/categories/题解/牛客/北邮/"}]},{"title":"牛客-北邮-比较奇偶数个数","slug":"牛客-北邮-比较奇偶数个数","date":"2018-01-26T13:40:59.000Z","updated":"2018-01-26T13:45:55.315Z","comments":true,"path":"题解/牛客/北邮/牛客-北邮-比较奇偶数个数/","link":"","permalink":"https://efinedxq.github.io/题解/牛客/北邮/牛客-北邮-比较奇偶数个数/","excerpt":"","text":"题目描述第一行输入一个数，为n，第二行输入n个数，这n个数中，如果偶数比奇数多，输出NO，否则输出YES。 输入描述:输入有多组数据。每组输入n，然后输入n个整数（1&lt;=n&lt;=1000）。 输出描述:如果偶数比奇数多，输出NO，否则输出YES。 示例1输入 51 5 2 4 3输出YES 分析遍历数组，偶数与奇数分别判断计数。然后做比较。 代码123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int n,t, num1=0, num2=0; cin&gt;&gt;n; while(n--) &#123; cin&gt;&gt;t; if(t&amp;1) num1++; else num2++; &#125; if(num1&lt;num2)&#123; cout&lt;&lt;\"NO\"; &#125;else&#123; cout&lt;&lt;\"YES\"; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"北邮","slug":"题解/牛客/北邮","permalink":"https://efinedxq.github.io/categories/题解/牛客/北邮/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://efinedxq.github.io/tags/数学/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"北邮","slug":"题解/牛客/北邮","permalink":"https://efinedxq.github.io/categories/题解/牛客/北邮/"}]},{"title":"牛客-北邮-哈夫曼树","slug":"牛客-北邮-哈夫曼树","date":"2018-01-26T13:27:17.000Z","updated":"2018-01-26T13:36:48.141Z","comments":true,"path":"题解/牛客/北邮/牛客-北邮-哈夫曼树/","link":"","permalink":"https://efinedxq.github.io/题解/牛客/北邮/牛客-北邮-哈夫曼树/","excerpt":"","text":"题目描述哈夫曼树，第一行输入一个数n，表示叶结点的个数。需要用这些叶结点生成哈夫曼树，根据哈夫曼树的概念，这些结点有权值，即weight，题目需要输出所有结点的值与权值的乘积之和。 输入描述:输入有多组数据。每组第一行输入一个数n，接着输入n个叶节点（叶节点权值不超过100，2&lt;=n&lt;=1000）。 输出描述:输出权值。 示例1输入 51 2 2 5 9 输出 37 分析利用优先队列，每次找队列中最小的两个相加，之后再将和存入队列。 代码1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; Q; int n,sum =0;; cin&gt;&gt;n; for(int i = 0; i &lt; n; i ++) &#123; int t; cin&gt;&gt;t; Q.push(t); &#125; while(Q.size()&gt;1)&#123; int a,b; a = Q.top(); Q.pop(); b = Q.top(); Q.pop(); a = a+b; Q.push(a); sum += a; &#125; cout&lt;&lt;sum; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"北邮","slug":"题解/牛客/北邮","permalink":"https://efinedxq.github.io/categories/题解/牛客/北邮/"}],"tags":[{"name":"优先队列","slug":"优先队列","permalink":"https://efinedxq.github.io/tags/优先队列/"},{"name":"哈夫曼树","slug":"哈夫曼树","permalink":"https://efinedxq.github.io/tags/哈夫曼树/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"北邮","slug":"题解/牛客/北邮","permalink":"https://efinedxq.github.io/categories/题解/牛客/北邮/"}]},{"title":"牛客-北邮-二进制","slug":"牛客-北邮-二进制","date":"2018-01-26T13:21:11.000Z","updated":"2018-01-26T13:37:00.079Z","comments":true,"path":"题解/牛客/北邮/牛客-北邮-二进制/","link":"","permalink":"https://efinedxq.github.io/题解/牛客/北邮/牛客-北邮-二进制/","excerpt":"","text":"题目描述大家都知道，数据在计算机里中存储是以二进制的形式存储的。 有一天，小明学了C语言之后，他想知道一个类型为unsigned int 类型的数字，存储在计算机中的二进制串是什么样子的。 你能帮帮小明吗？并且，小明不想要二进制串中前面的没有意义的0串，即要去掉前导0。 输入描述:每行有一个数字n（0&lt;=n&lt;=10^8），表示要求的二进制串。 输出描述:输出共T行。每行输出求得的二进制串。 示例1输入 23 输出 10111 分析数学题，除留余数。注意是倒序输出，所以用了栈，也可以不用。 代码12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; stack&lt;char&gt; s; int n,t; cin&gt;&gt;n; while(n)&#123; t = n %2; if(t) s.push('1'); else s.push('0'); n/=2; &#125; while(!s.empty())&#123; cout&lt;&lt;(s.top()); s.pop(); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"北邮","slug":"题解/牛客/北邮","permalink":"https://efinedxq.github.io/categories/题解/牛客/北邮/"}],"tags":[{"name":"二进制","slug":"二进制","permalink":"https://efinedxq.github.io/tags/二进制/"},{"name":"数学","slug":"数学","permalink":"https://efinedxq.github.io/tags/数学/"},{"name":"栈","slug":"栈","permalink":"https://efinedxq.github.io/tags/栈/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"牛客","slug":"题解/牛客","permalink":"https://efinedxq.github.io/categories/题解/牛客/"},{"name":"北邮","slug":"题解/牛客/北邮","permalink":"https://efinedxq.github.io/categories/题解/牛客/北邮/"}]},{"title":"LeetCode_problem_4_Median_of_Two_Sorted_Arrays","slug":"LeetCode-problem-4-Median-of-Two-Sorted-Arrays","date":"2018-01-19T02:15:10.000Z","updated":"2018-01-26T11:05:58.267Z","comments":true,"path":"题解/LeetCode/LeetCode-problem-4-Median-of-Two-Sorted-Arrays/","link":"","permalink":"https://efinedxq.github.io/题解/LeetCode/LeetCode-problem-4-Median-of-Two-Sorted-Arrays/","excerpt":"","text":"问题描述There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). 找中间数字。 例子Example 1:nums1 = [1, 3]nums2 = [2]The median is 2.0 Example 2:nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 思路 合并两个数组，然后找到中间值。这是最笨的方法。 题目没有要求输出合并后的数组，所以没必要全部比较，可以记录比较的长度，只要达到中间长度就停止。 进一步优化，不用辅助数组，试探性查找。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243 /** * 将两者不完全合并，即只要合并到len长度即可。* 用了一个辅助vector。 68ms*/ double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int len1 = nums1.size(), len2=nums2.size(); int len = (len1+len2)/2, f = (len1+len2)%2; vector&lt;int&gt; tem; double ans = 0; int i = 0, j= 0; while(i&lt;len1&amp;&amp;j&lt;len2&amp;&amp;i+j&lt;len+1)&#123; if(nums1[i]&gt;nums2[j])&#123; tem.push_back(nums2[j]); j++; &#125;else&#123; tem.push_back(nums1[i]); i++; &#125; cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;j&lt;&lt;endl; &#125; while(i+j&lt;len+1)&#123; if(i&lt;len1)&#123; tem.push_back(nums1[i]); i++; &#125; if(j&lt;len2)&#123; tem.push_back(nums2[j]); j++; &#125; cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;j&lt;&lt;endl; &#125; cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;j&lt;&lt;\" \"&lt;&lt;len&lt;&lt;endl; if(f&gt;0)&#123; ans = tem[len]; &#125;else&#123; ans = double(tem[len-1]+tem[len])/2; &#125; return ans; &#125; 不用vector12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 /*** 不用vector 思路一样 但用了更长的时间 90ms*/double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int len1 = nums1.size(), len2=nums2.size(); int len = (len1+len2)/2, f = (len1+len2)%2; double ans = 0, tem = 0; int i = 0, j= 0; while(i&lt;len1&amp;&amp;j&lt;len2&amp;&amp;i+j&lt;len+1)&#123; if(nums1[i]&gt;nums2[j])&#123; if(i+j==len-1)&#123; tem = nums2[j]; &#125; if(i+j==len)&#123; ans = nums2[j]; &#125; j++; &#125;else&#123; if(i+j==len-1)&#123; tem = nums1[i]; &#125; if(i+j==len)&#123; ans = nums1[i]; &#125; i++; &#125; cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;j&lt;&lt;endl; &#125; while(i+j&lt;len+1)&#123; if(i&lt;len1)&#123; if(i+j==len-1)&#123; tem = nums1[i]; &#125; if(i+j==len)&#123; ans = nums1[i]; &#125; i++; &#125; if(j&lt;len2)&#123; if(i+j==len-1)&#123; tem = nums2[j]; &#125; if(i+j==len)&#123; ans = nums2[j]; &#125; j++; &#125; cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;j&lt;&lt;endl; &#125; cout&lt;&lt;i&lt;&lt;\" \"&lt;&lt;j&lt;&lt;\" \"&lt;&lt;len&lt;&lt;endl; if(f&gt;0)&#123; return ans; &#125;else&#123; return (ans+tem)/2; &#125; &#125; 进一步优化123456789101112131415161718192021222324252627282930313233343536 /*** 例程，55ms**/ double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int len1 = nums1.size(), len2=nums2.size(); if(len1&gt;len2)&#123; vector&lt;int&gt; tem = nums1; nums1 = nums2; nums2=tem; int t = len1; len1 = len2; len2 = t; &#125; int iMin = 0, iMax = len1, half = (len1+len2+1)/2; while(iMin &lt;= iMax)&#123; int i = (iMin + iMax)/2; int j = half - i; if (i &lt; iMax &amp;&amp; nums2[j-1] &gt; nums1[i])&#123; iMin = iMin + 1; // i is too small &#125; else if (i &gt; iMin &amp;&amp; nums1[i-1] &gt; nums2[j]) &#123; iMax = iMax - 1; // i is too big &#125; else &#123; // i is perfect int maxLeft = 0; if (i == 0) &#123; maxLeft =nums2[j-1]; &#125; else if (j == 0) &#123; maxLeft = nums1[i-1]; &#125; else &#123; maxLeft = max(nums1[i-1], nums2[j-1]); &#125; if ( (len1 + len2) % 2 == 1 ) &#123; return maxLeft; &#125; int minRight = 0; if (i == len1) &#123; minRight = nums2[j]; &#125; else if (j == len2) &#123; minRight = nums1[i]; &#125; else &#123; minRight = min(nums2[j], nums1[i]); &#125; return (maxLeft + minRight) / 2.0; &#125; &#125; return 0.0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"LeetCode","slug":"题解/LeetCode","permalink":"https://efinedxq.github.io/categories/题解/LeetCode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://efinedxq.github.io/tags/leetcode/"},{"name":"数组","slug":"数组","permalink":"https://efinedxq.github.io/tags/数组/"},{"name":"中间数","slug":"中间数","permalink":"https://efinedxq.github.io/tags/中间数/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"LeetCode","slug":"题解/LeetCode","permalink":"https://efinedxq.github.io/categories/题解/LeetCode/"}]},{"title":"LeetCode_problem_3_Longest_Substring_Without_Repeating_Characters","slug":"LeetCode-problem-3-Longest-Substring-Without-Repeating-Characters","date":"2018-01-19T02:11:23.000Z","updated":"2018-01-26T11:05:43.985Z","comments":true,"path":"题解/LeetCode/LeetCode-problem-3-Longest-Substring-Without-Repeating-Characters/","link":"","permalink":"https://efinedxq.github.io/题解/LeetCode/LeetCode-problem-3-Longest-Substring-Without-Repeating-Characters/","excerpt":"","text":"问题描述 Given a string, find the length of the longest substring without repeating characters. （找出最长的没有重复字母出现的子串。输出其最长长度。） 例子 Given “abcabcbb”, the answer is “abc”, which the length is 3. Given “bbbbb”, the answer is “b”, with the length of 1. Given “pwwkew”, the answer is “wke”, with the length of 3. Note that the answer must be a substring, “pwke” is a subsequence and not a substring. 思路 有一个结论只要重复出现，index之前的东西就失去了作用，只用记录index之后的字符。 如果不是重复字符， index==-1 ,那么就让max++; 如果不是重复字符，index!=-1，就比较记录max。不能直接max++，也不能直接max=i-index; 例如：abcaad 如果出现重复，并且是在index之后出现，给记录，再比较max 如果出现重复，在index之前出现，比较记录max 测试用例&quot;abcabcss&quot; 4 &quot;aaaaa&quot; 1 &quot;qwwwejw&quot; 3 &quot;abcade&quot; 5 &quot;abba&quot; 2 index之前的就不算了 &quot;ohomm&quot; 3 &quot;tmmzuxt&quot; 5 因为t出现过，所以return的判断还是有必要的 &quot;alouzxilkaxkufsu&quot; 8 代码12345678910111213141516171819202122232425262728293031class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int index = -1; //每遇到重复值，就记录下其第一次出现的下标 int max = 0, len = s.size(); //max记录当前最长 int mapping[200] = &#123;0&#125;; int val; // 记录字符 for(int i = 0; i &lt; len; i ++)&#123; val = s[i]; //如果出现过，并且是在index之后出现，给记录 if(mapping[val]&gt;0)&#123; if(index &lt;= mapping[val]-1)&#123; index = mapping[val]-1; &#125; max = max&gt;=i-index?max:i-index; &#125; //if(index==-1) max++; // if(mapping[val]&lt;=0) &#123; if(index==-1) max++; else&#123; max = max&gt;=i-index?max:i-index; &#125; &#125; cout&lt;&lt;index&lt;&lt;\" \"&lt;&lt;max&lt;&lt;\" \"&lt;&lt;val&lt;&lt;endl; mapping[val] = i+1; &#125; if(index == -1) return max; else return max&gt;=len-index-1?max:len-index-1; &#125;&#125;; 改进版1234567891011121314 int lengthOfLongestSubstring(string s) &#123; int index = 0; //每遇到重复值，就记录下其第一次出现的下标 int max = 0, len = s.size(); //max记录当前最长 int mapping[200] = &#123;0&#125;; int val; // 记录字符 for(int i = 0; i &lt; len; i ++)&#123; val = s[i]; index = mapping[val]&gt;index?mapping[val]:index; max = max&gt;i-index+1?max:i-index+1; mapping[val] = i+1; &#125; return max; &#125; 补充ASCII码 &apos;a&apos; 97 &apos;A&apos; 65 &apos;0&apos; 48 &apos;z&apos; 122 &apos;Z&apos; 90 &apos;9&apos; 57","categories":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"LeetCode","slug":"题解/LeetCode","permalink":"https://efinedxq.github.io/categories/题解/LeetCode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://efinedxq.github.io/tags/leetcode/"},{"name":"字符串","slug":"字符串","permalink":"https://efinedxq.github.io/tags/字符串/"},{"name":"最长子串","slug":"最长子串","permalink":"https://efinedxq.github.io/tags/最长子串/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"LeetCode","slug":"题解/LeetCode","permalink":"https://efinedxq.github.io/categories/题解/LeetCode/"}]},{"title":"LeetCode_problem_2_Add_Two_Numbers","slug":"LeetCode-problem-2-Add-Two-Numbers","date":"2018-01-19T02:08:37.000Z","updated":"2018-01-26T11:02:16.097Z","comments":true,"path":"题解/LeetCode/LeetCode-problem-2-Add-Two-Numbers/","link":"","permalink":"https://efinedxq.github.io/题解/LeetCode/LeetCode-problem-2-Add-Two-Numbers/","excerpt":"","text":"问题描述You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. 假定两个数都不是0开头，除了数本身就是0。 例子Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 思路题目没什么难点，就是链表的顺序遍历问题。注意进位就行了，可能最后有一个进位要再创建一个节点，不要漏掉。 代码1234567891011121314151617181920212223242526272829303132333435363738/** * C++ 代码 * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode head(-1); int f = 0; //标识进位 ListNode* pre = &amp;head; ListNode* pa = l1, *pb = l2; int val = 0, a, b; while(pa!=nullptr||pb!=nullptr)&#123; a = pa == nullptr?0:pa-&gt;val; b = pb == nullptr?0:pb-&gt;val; val = a + b + f; f = val / 10; val = val % 10; pre-&gt;next = new ListNode(val); pa=pa==nullptr?nullptr:pa-&gt;next; pb=pb==nullptr?nullptr:pb-&gt;next; pre = pre-&gt;next; &#125; //最后判断是否有进位 if(f&gt;0)&#123; pre-&gt;next = new ListNode(f); &#125; return head.next; &#125;&#125;;","categories":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"LeetCode","slug":"题解/LeetCode","permalink":"https://efinedxq.github.io/categories/题解/LeetCode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://efinedxq.github.io/tags/leetcode/"},{"name":"数组","slug":"数组","permalink":"https://efinedxq.github.io/tags/数组/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"LeetCode","slug":"题解/LeetCode","permalink":"https://efinedxq.github.io/categories/题解/LeetCode/"}]},{"title":"LeetCode_problem_1_two_sum","slug":"LeetCode-problem-1-two-sum","date":"2018-01-19T01:40:09.000Z","updated":"2018-01-26T11:02:01.734Z","comments":true,"path":"题解/LeetCode/LeetCode-problem-1-two-sum/","link":"","permalink":"https://efinedxq.github.io/题解/LeetCode/LeetCode-problem-1-two-sum/","excerpt":"","text":"Description Given an array of integers, return indices of the two numbers suchthat they add up to a specific target. You may assume that each input would have exactly one solution, andyou may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. 测试用例 输入：3,3 6输出： 0,1 输入：2,3,3 5 输出： 0,1 下面代码没有通过这个测试，但是A了。题目说结果是确定的，应该就是不考虑这种情况。 思路 先排序，最快O(nlogn)。再左右夹逼。比较暴力。 利用hash表，时间复杂度为O(n)。下面代码是基于第二种方法。 代码1234567891011121314151617vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int,int&gt; hashMap; for(int i = 0; i&lt;nums.size(); i ++) hashMap[nums[i]] = i; //cout&lt;&lt;hashMap.size()&lt;&lt;endl; vector&lt;int&gt; ans; for(int i = 0; i&lt;nums.size(); i ++)&#123; const int gap = target - nums[i]; if(hashMap[gap] &gt; 0)&#123; ans.push_back(i); ans.push_back(hashMap[gap]); break; &#125; &#125; return ans; &#125; 官方java答案123456789101112public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; return new int[] &#123; map.get(complement), i &#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException(\"No two sum solution\"); &#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"LeetCode","slug":"题解/LeetCode","permalink":"https://efinedxq.github.io/categories/题解/LeetCode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://efinedxq.github.io/tags/leetcode/"},{"name":"链表","slug":"链表","permalink":"https://efinedxq.github.io/tags/链表/"}],"keywords":[{"name":"题解","slug":"题解","permalink":"https://efinedxq.github.io/categories/题解/"},{"name":"LeetCode","slug":"题解/LeetCode","permalink":"https://efinedxq.github.io/categories/题解/LeetCode/"}]},{"title":"Hexo博客添加图片、音乐、视频","slug":"添加视频音乐图片","date":"2018-01-18T04:38:23.000Z","updated":"2018-01-26T10:55:15.913Z","comments":true,"path":"hexo/添加视频音乐图片/","link":"","permalink":"https://efinedxq.github.io/hexo/添加视频音乐图片/","excerpt":"","text":"1. 插入外部链接图片 1![“图片描述”](“图片地址”) 2. 添加本地图片 在\\hexo\\source目录下新建文件夹，命名为images或者其他你喜欢的名字，然后编辑你的md博文，插入下面的代码样式： 1![“图片描述”](/images/你的图片名字.JPG) 3. 插入音乐 比如网易云音乐，找到喜欢的歌曲，点击分享按钮，把里面的代码复制下来，直接粘贴到博文中即可 4. 插入视频 Idina Menze和Caleb Hyles激情对唱Let It Go：","categories":[{"name":"hexo","slug":"hexo","permalink":"https://efinedxq.github.io/categories/hexo/"}],"tags":[{"name":"博客配置","slug":"博客配置","permalink":"https://efinedxq.github.io/tags/博客配置/"}],"keywords":[{"name":"hexo","slug":"hexo","permalink":"https://efinedxq.github.io/categories/hexo/"}]}]}